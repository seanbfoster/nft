{"ast":null,"code":"import Web3 from \"web3\";\n\nrequire(\"dotenv\").config();\n\nconst alchemyKey = process.env.REACT_APP_ALCHEMY_KEY;\n\nconst contractABI = require(\"../contract-abi.json\");\n\nconst contractAddress = \"0xC73B2C2A555F845796A42c69B5b6Bc21394929A1\";\n\nconst {\n  createAlchemyWeb3\n} = require(\"@alch/alchemy-web3\");\n\nconst web3alch = createAlchemyWeb3(alchemyKey);\nimport detectEthereumProvider from '@metamask/detect-provider';\nconst provider = await detectEthereumProvider();\nexport const connectWallet = async () => {\n  if (window.ethereum) {\n    try {\n      const addressArray = await window.ethereum.request({\n        method: \"eth_requestAccounts\"\n      });\n      const obj = {\n        status: \"Wallet Connected\",\n        address: addressArray[0]\n      };\n      return obj;\n    } catch (err) {\n      return {\n        address: \"\",\n        status: \"Error: \" + err.message\n      };\n    }\n  } else {\n    return {\n      address: \"\",\n      status: \"Install Metamask\"\n    };\n  }\n};\nexport const getCurrentWalletConnected = async () => {\n  if (window.ethereum) {\n    try {\n      const addressArray = await window.ethereum.request({\n        method: \"eth_accounts\"\n      });\n\n      if (addressArray.length > 0) {\n        return {\n          address: addressArray[0],\n          status: \"Wallet Connected\"\n        };\n      } else {\n        return {\n          address: \"\",\n          status: \"Connect your wallet\"\n        };\n      }\n    } catch (err) {\n      return {\n        address: \"\",\n        status: \"Error: \" + err.message\n      };\n    }\n  } else {\n    return {\n      address: \"\",\n      status: \"Install Metamask\"\n    };\n  }\n};\n\nasync function loadContract() {\n  return new web3alch.eth.Contract(contractABI, contractAddress);\n}\n\nexport const mintNFT = async quantity => {\n  alert(ethereum.isConnected());\n}; // const mintPrice = Web3.utils.toWei('.07', 'ether')\n// window.contract = await new web3alch.eth.Contract(contractABI, contractAddress);\n// const transactionParameters = {\n//   to: contractAddress, // Required except during contract publications.\n//   from: window.ethereum.selectedAddress, // must match user's active address.\n//   value: Web3.utils.toHex(mintPrice * quantity),\n//   'data': window.contract.methods.mintTeslaBot(1).encodeABI() //make call to NFT smart contract \n// };\n// try {\n//   const txHash = await window.ethereum.request({\n//     method: \"eth_sendTransaction\",\n//     params: [transactionParameters],\n//   });\n//   return {\n//     success: true,\n//     status:\n//       \"✅ Check out your transaction on Etherscan: https://ropsten.etherscan.io/tx/\" +\n//       txHash,\n//   };\n// } catch (error) {\n//   alert(error.message)\n//   return {\n//     success: false,\n//     status: \"Error: \" + error.message,\n//   };","map":{"version":3,"sources":["/Users/seanfoster/Documents/nft-minter-tutorial/nft-minter/src/util/interact.js"],"names":["Web3","require","config","alchemyKey","process","env","REACT_APP_ALCHEMY_KEY","contractABI","contractAddress","createAlchemyWeb3","web3alch","detectEthereumProvider","provider","connectWallet","window","ethereum","addressArray","request","method","obj","status","address","err","message","getCurrentWalletConnected","length","loadContract","eth","Contract","mintNFT","quantity","alert","isConnected"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;;AAEAC,OAAO,CAAC,QAAD,CAAP,CAAkBC,MAAlB;;AACA,MAAMC,UAAU,GAAGC,OAAO,CAACC,GAAR,CAAYC,qBAA/B;;AACA,MAAMC,WAAW,GAAGN,OAAO,CAAC,sBAAD,CAA3B;;AACA,MAAMO,eAAe,GAAG,4CAAxB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAwBR,OAAO,CAAC,oBAAD,CAArC;;AACA,MAAMS,QAAQ,GAAGD,iBAAiB,CAACN,UAAD,CAAlC;AAEA,OAAOQ,sBAAP,MAAmC,2BAAnC;AAEA,MAAMC,QAAQ,GAAG,MAAMD,sBAAsB,EAA7C;AAGA,OAAO,MAAME,aAAa,GAAG,YAAY;AACvC,MAAIC,MAAM,CAACC,QAAX,EAAqB;AACnB,QAAI;AACF,YAAMC,YAAY,GAAG,MAAMF,MAAM,CAACC,QAAP,CAAgBE,OAAhB,CAAwB;AACjDC,QAAAA,MAAM,EAAE;AADyC,OAAxB,CAA3B;AAGA,YAAMC,GAAG,GAAG;AACVC,QAAAA,MAAM,EAAE,kBADE;AAEVC,QAAAA,OAAO,EAAEL,YAAY,CAAC,CAAD;AAFX,OAAZ;AAIA,aAAOG,GAAP;AACD,KATD,CASE,OAAOG,GAAP,EAAY;AACZ,aAAO;AACLD,QAAAA,OAAO,EAAE,EADJ;AAELD,QAAAA,MAAM,EAAE,YAAYE,GAAG,CAACC;AAFnB,OAAP;AAID;AACF,GAhBD,MAgBO;AACL,WAAO;AACLF,MAAAA,OAAO,EAAE,EADJ;AAELD,MAAAA,MAAM,EAAE;AAFH,KAAP;AAID;AACF,CAvBM;AAyBP,OAAO,MAAMI,yBAAyB,GAAG,YAAY;AACnD,MAAIV,MAAM,CAACC,QAAX,EAAqB;AACnB,QAAI;AACF,YAAMC,YAAY,GAAG,MAAMF,MAAM,CAACC,QAAP,CAAgBE,OAAhB,CAAwB;AACjDC,QAAAA,MAAM,EAAE;AADyC,OAAxB,CAA3B;;AAGA,UAAIF,YAAY,CAACS,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,eAAO;AACLJ,UAAAA,OAAO,EAAEL,YAAY,CAAC,CAAD,CADhB;AAELI,UAAAA,MAAM,EAAE;AAFH,SAAP;AAID,OALD,MAKO;AACL,eAAO;AACLC,UAAAA,OAAO,EAAE,EADJ;AAELD,UAAAA,MAAM,EAAE;AAFH,SAAP;AAID;AACF,KAfD,CAeE,OAAOE,GAAP,EAAY;AACZ,aAAO;AACLD,QAAAA,OAAO,EAAE,EADJ;AAELD,QAAAA,MAAM,EAAE,YAAYE,GAAG,CAACC;AAFnB,OAAP;AAID;AACF,GAtBD,MAsBO;AACL,WAAO;AACLF,MAAAA,OAAO,EAAE,EADJ;AAELD,MAAAA,MAAM,EAAE;AAFH,KAAP;AAID;AACF,CA7BM;;AA+BP,eAAeM,YAAf,GAA8B;AAC5B,SAAO,IAAIhB,QAAQ,CAACiB,GAAT,CAAaC,QAAjB,CAA0BrB,WAA1B,EAAuCC,eAAvC,CAAP;AACD;;AAED,OAAO,MAAMqB,OAAO,GAAG,MAAOC,QAAP,IAAoB;AAEzCC,EAAAA,KAAK,CAAChB,QAAQ,CAACiB,WAAT,EAAD,CAAL;AAED,CAJM,C,CAKL;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import Web3 from \"web3\";\n\nrequire(\"dotenv\").config();\nconst alchemyKey = process.env.REACT_APP_ALCHEMY_KEY;\nconst contractABI = require(\"../contract-abi.json\");\nconst contractAddress = \"0xC73B2C2A555F845796A42c69B5b6Bc21394929A1\";\nconst { createAlchemyWeb3 } = require(\"@alch/alchemy-web3\");\nconst web3alch = createAlchemyWeb3(alchemyKey);\n\nimport detectEthereumProvider from '@metamask/detect-provider';\n\nconst provider = await detectEthereumProvider();\n\n\nexport const connectWallet = async () => {\n  if (window.ethereum) {\n    try {\n      const addressArray = await window.ethereum.request({\n        method: \"eth_requestAccounts\",\n      });\n      const obj = {\n        status: \"Wallet Connected\",\n        address: addressArray[0],\n      };\n      return obj;\n    } catch (err) {\n      return {\n        address: \"\",\n        status: \"Error: \" + err.message,\n      };\n    }\n  } else {\n    return {\n      address: \"\",\n      status: \"Install Metamask\"\n    };\n  }\n};\n\nexport const getCurrentWalletConnected = async () => {\n  if (window.ethereum) {\n    try {\n      const addressArray = await window.ethereum.request({\n        method: \"eth_accounts\",\n      });\n      if (addressArray.length > 0) {\n        return {\n          address: addressArray[0],\n          status: \"Wallet Connected\",\n        };\n      } else {\n        return {\n          address: \"\",\n          status: \"Connect your wallet\",\n        };\n      }\n    } catch (err) {\n      return {\n        address: \"\",\n        status: \"Error: \" + err.message,\n      };\n    }\n  } else {\n    return {\n      address: \"\",\n      status: \"Install Metamask\"\n    };\n  }\n};\n\nasync function loadContract() {\n  return new web3alch.eth.Contract(contractABI, contractAddress);\n}\n\nexport const mintNFT = async (quantity) => {\n\n  alert(ethereum.isConnected())\n\n}\n  // const mintPrice = Web3.utils.toWei('.07', 'ether')\n  \n  // window.contract = await new web3alch.eth.Contract(contractABI, contractAddress);\n\n  // const transactionParameters = {\n  //   to: contractAddress, // Required except during contract publications.\n  //   from: window.ethereum.selectedAddress, // must match user's active address.\n  //   value: Web3.utils.toHex(mintPrice * quantity),\n  //   'data': window.contract.methods.mintTeslaBot(1).encodeABI() //make call to NFT smart contract \n  // };\n\n  // try {\n  //   const txHash = await window.ethereum.request({\n  //     method: \"eth_sendTransaction\",\n  //     params: [transactionParameters],\n  //   });\n  //   return {\n  //     success: true,\n  //     status:\n  //       \"✅ Check out your transaction on Etherscan: https://ropsten.etherscan.io/tx/\" +\n  //       txHash,\n  //   };\n  // } catch (error) {\n  //   alert(error.message)\n  //   return {\n  //     success: false,\n  //     status: \"Error: \" + error.message,\n  //   };\n"]},"metadata":{},"sourceType":"module"}