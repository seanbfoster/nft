{"ast":null,"code":"require(\"dotenv\").config();\n\nconst alchemyKey = process.env.REACT_APP_ALCHEMY_KEY;\n\nconst contractABI = require(\"../contract-abi.json\");\n\nconst contractAddress = \"0xC73B2C2A555F845796A42c69B5b6Bc21394929A1\";\n\nconst {\n  createAlchemyWeb3\n} = require(\"@alch/alchemy-web3\");\n\nconst web3 = createAlchemyWeb3(alchemyKey);\nexport const connectWallet = async () => {\n  if (window.ethereum) {\n    try {\n      const addressArray = await window.ethereum.request({\n        method: \"eth_requestAccounts\"\n      });\n      const obj = {\n        status: \"Wallet Connected\",\n        address: addressArray[0]\n      };\n      return obj;\n    } catch (err) {\n      return {\n        address: \"\",\n        status: \"Error: \" + err.message\n      };\n    }\n  } else {\n    return {\n      address: \"\",\n      status: \"Install Metamask\"\n    };\n  }\n};\nexport const getCurrentWalletConnected = async () => {\n  if (window.ethereum) {\n    try {\n      const addressArray = await window.ethereum.request({\n        method: \"eth_accounts\"\n      });\n\n      if (addressArray.length > 0) {\n        return {\n          address: addressArray[0],\n          status: \"Wallet Connected\"\n        };\n      } else {\n        return {\n          address: \"\",\n          status: \"Connect your wallet\"\n        };\n      }\n    } catch (err) {\n      return {\n        address: \"\",\n        status: \"Error: \" + err.message\n      };\n    }\n  } else {\n    return {\n      address: \"\",\n      status: \"Install Metamask\"\n    };\n  }\n};\n\nasync function loadContract() {\n  return new web3.eth.Contract(contractABI, contractAddress);\n}\n\nexport const mintNFT = async quantity => {\n  window.contract = await new web3.eth.Contract(contractABI, contractAddress);\n  const transactionParameters = {\n    to: contractAddress,\n    // Required except during contract publications.\n    from: window.ethereum.selectedAddress,\n    // must match user's active address.\n    value: \"1000000000000000\",\n    'data': window.contract.methods.mintTeslaBot(1).encodeABI() //make call to NFT smart contract \n\n  };\n\n  try {\n    const txHash = await window.ethereum.request({\n      method: \"eth_sendTransaction\",\n      params: [transactionParameters]\n    });\n    return {\n      success: true,\n      status: \"✅ Check out your transaction on Etherscan: https://ropsten.etherscan.io/tx/\" + txHash\n    };\n  } catch (error) {\n    alert(error.message);\n    return {\n      success: false,\n      status: \"Error: \" + error.message\n    };\n  }\n};","map":{"version":3,"sources":["/Users/seanfoster/Documents/nft-minter-tutorial/nft-minter/src/util/interact.js"],"names":["require","config","alchemyKey","process","env","REACT_APP_ALCHEMY_KEY","contractABI","contractAddress","createAlchemyWeb3","web3","connectWallet","window","ethereum","addressArray","request","method","obj","status","address","err","message","getCurrentWalletConnected","length","loadContract","eth","Contract","mintNFT","quantity","contract","transactionParameters","to","from","selectedAddress","value","methods","mintTeslaBot","encodeABI","txHash","params","success","error","alert"],"mappings":"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","sourcesContent":["require(\"dotenv\").config();\nconst alchemyKey = process.env.REACT_APP_ALCHEMY_KEY;\nconst contractABI = require(\"../contract-abi.json\");\nconst contractAddress = \"0xC73B2C2A555F845796A42c69B5b6Bc21394929A1\";\nconst { createAlchemyWeb3 } = require(\"@alch/alchemy-web3\");\nconst web3 = createAlchemyWeb3(alchemyKey);\n\nexport const connectWallet = async () => {\n  if (window.ethereum) {\n    try {\n      const addressArray = await window.ethereum.request({\n        method: \"eth_requestAccounts\",\n      });\n      const obj = {\n        status: \"Wallet Connected\",\n        address: addressArray[0],\n      };\n      return obj;\n    } catch (err) {\n      return {\n        address: \"\",\n        status: \"Error: \" + err.message,\n      };\n    }\n  } else {\n    return {\n      address: \"\",\n      status: \"Install Metamask\"\n    };\n  }\n};\n\nexport const getCurrentWalletConnected = async () => {\n  if (window.ethereum) {\n    try {\n      const addressArray = await window.ethereum.request({\n        method: \"eth_accounts\",\n      });\n      if (addressArray.length > 0) {\n        return {\n          address: addressArray[0],\n          status: \"Wallet Connected\",\n        };\n      } else {\n        return {\n          address: \"\",\n          status: \"Connect your wallet\",\n        };\n      }\n    } catch (err) {\n      return {\n        address: \"\",\n        status: \"Error: \" + err.message,\n      };\n    }\n  } else {\n    return {\n      address: \"\",\n      status: \"Install Metamask\"\n    };\n  }\n};\n\nasync function loadContract() {\n  return new web3.eth.Contract(contractABI, contractAddress);\n}\n\nexport const mintNFT = async (quantity) => {\n  window.contract = await new web3.eth.Contract(contractABI, contractAddress);\n\n  const transactionParameters = {\n    to: contractAddress, // Required except during contract publications.\n    from: window.ethereum.selectedAddress, // must match user's active address.\n    value: \"1000000000000000\",\n    'data': window.contract.methods.mintTeslaBot(1).encodeABI() //make call to NFT smart contract \n  };\n\n\n  try {\n    const txHash = await window.ethereum.request({\n      method: \"eth_sendTransaction\",\n      params: [transactionParameters],\n    });\n    return {\n      success: true,\n      status:\n        \"✅ Check out your transaction on Etherscan: https://ropsten.etherscan.io/tx/\" +\n        txHash,\n    };\n  } catch (error) {\n    alert(error.message)\n    return {\n      success: false,\n      status: \"Error: \" + error.message,\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}